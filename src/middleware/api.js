// API MIDDLEWARE
// ==============
// Takes an action with a `fetchApi` property and converts to promise.
// The promise is generated by `fetch`.
// If the fetch response has a status code within 200-299 range
// the promise will resolve, if not the promise will reject.

const getQueryString = params =>
  Object.keys(params)
    .map(key => `${encodeURIComponent(key)}=${encodeURIComponent(params[key])}`)
    .join('&');

const delay = duration =>
  new Promise(resolve =>
    (duration && duration > 0 ? setTimeout(resolve, duration) : resolve()));

const delayDuration = process.env.NODE_ENV === 'production' ? 1000 : 500;

export default (
  baseUrl = '/',
  defaultOptions = {
    headers: {
      Accept: 'application/json, text/plain, */*',
      'Content-Type': 'application/json',
    },
  },
) => () => next => ({ fetchApi, ...action }) => {
  // If the action does not contain a `fetchApi` property,
  // pass the action to the next middleware in the stack.
  if (!fetchApi) {
    return next(action);
  }

  const { data, ...options } = fetchApi;
  const requestInit = {
    method: 'GET',
    ...defaultOptions,
    ...options,
  };

  let querystring = '';

  if (data) {
    if (['GET', 'DELETE'].indexOf(requestInit.method) > -1) {
      querystring = `?${getQueryString(data)}`;
    } else {
      requestInit.body = JSON.stringify(data);
    }
  }

  const url = `${baseUrl}${fetchApi.url}${querystring}`;

  const newAction = {
    ...action,
    payload: fetch(url, requestInit).then(response =>
      response.json().then((body) => {
        const newInnerAction = {
          ...action,
          payload: {
            success: response.ok,
            status: response.status,
            statusText: response.statusText,
            body,
          },
        };

        return delay(delayDuration).then(() =>
          (response.ok
            ? Promise.resolve(newInnerAction)
            : Promise.reject(newInnerAction)));
      })),
  };

  return next(newAction);
};
